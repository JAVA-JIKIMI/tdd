# 1주차

# 📌 인상 깊었던 내용

## **📚 private 메서드 생성**

> 테스트와 코드 사이의 결합도를 낮추기 위해, 테스트하는 객체의 새기능을 사용했다
> 
> 📕  68p  8번째 ( 4장)
> 

```java
public void testMultiplication() {
	Dollar five = new Dollar(5);
	Dollar product = five.times(2);
	assertEquals(10, product.amount);
}
```

이는 Dollar를 비교하는 방식으로 재작성할 수 있다

```java
public void testMultiplication() {
	Dollar five = new Dollar(5);
	Dollar product = five.times(2);
	assertEquals(new Dollar(10), product);
}
```

테스트를 고치고 나니 이제 Dollar의 amount 인스턴스 변수를 사용하는 코드는 Dollar 자신밖에 없게 됐다. 따라서 변수를 private으로 변경할 수 있다

### **🧐 : 리팩토링 과정에서 내부 변수나 메서드를 캡슐화하여 private으로 변경하는 과정도 필수 과정으로 수행해야겠다**

## **📚 컴파일 오류**

> 방금 우리가 작성한 테스트는 아직 컴파일조차 되지 않는다. 실행은 안되더라도 컴파일만은 되게 만들고 싶은데, 가장 쉬운 방법이 무엇일까?
> 
> - Dollar 클래스가 없음
> - 생성자가 없음
> - times(int) 메서드가 없음
> - amount 필드가 없음
> 
> 📕  44p  1번째 (1장)
> 

### **🧐 : 컴파일 오류 해결 과정은 어느 단계에서 수행해야 할지 애매했는데 테스트를 성공하기 위한 단계 이전에 선행되어야 하는 작업으로 인지하면 되겠다**

## **📚 지금까지 한 작업**

> 우리는 다음 작업들을 해냈다
> 
> - 우리가 알고 있는 작업해야 할 테스트 목록을 만들었다
> - 오퍼레이션이 외부에서 어떻게 보이길 원하는지 말해주는 이야기를 코드로 표현했다
> - 스텁 구현을 통해 테스트를 컴파일했다
> - 끔찍한 죄악을 범하여 테스트를 통과시켰다
> - 돌아가는 코드에서 상수를 변수로 변경하여 점진적으로 일반화했다
> - 새로운 할일들을 한번에 처리하는 대신 할일 목록에 추가하고 넘어갔다
> 
> 📕  51p  4번째 ( 1장)
> 

### **🧐 : 테스트 코드를 하는 과정을 상기하기 위해 적어놨다**

## **📚 중복제거는 선택이 아닌 필수다**

> 1. 테스트 작성
> 2. 컴파일되게 하기
> 3. 실패하는지 확인하기 위해 실행
> 4. 실행하게 만듦
> 5. 중복 제거
> 
> 주기의 다섯 번째 단계 없이는 앞의 네 단계도 제대로 되지 않는다. 적절한 시기에 적절한 설계를. 돌아가게 만들고, 올바르게 만들어라. 
> …
> 중복이 사라지기 전에는 집에 가지 않겠다고 약속해라..
> 
> 📕  71p  1번째 ( 5장)
> 

### **🧐 : 1~4단계는 동작하기 위한 단계이고, 5단계는 어쩌면 주관적인 의견일수 있지만 5단계를 얼마나 잘 구현하느냐에 따라 소프트웨어의 퀄리티를 보장할 수 있다**

---

# 📌 이해가 가지 않았던 내용

## **📚 추상화**

> - 공통된 코드를 첫 번째 클래스(Dollar)에서 상위 클래스(Money)로 단계적으로 옮겼다
> - 두 번째 클래스(Franc, Dollar)도 Money의 하위 클래스로 만들었다
> - 불필요한 구현을 제거하기 전에 두 quals() 구현을 일치시켰다
> 
> 📕  81p  5번째 ( 6장)
> 

### **🧐 : 공통된 코드를 중복제거하기 위해 용도의 상속은 위험하다고 생각하는데 괜찮을지? (Stack, Rectangle)**

## **📚 객체만들기**

> 하위 클래스의 존재를 테스트에서 분리(decoupling)함으로써 어떤 모델 코드에도 영향을 주지 않고 상속 구조를 마음대로 변경할 수 있게 됐다. 
> 
> 📕  91p  4번째 ( 8장)
> 

### **🧐 : 이 부분은 결합도를 낮춘 사례로 보는게 맞을지 의문이다.. 콘트리트 클래스를 직접적으로 사용하는 로직에선 오히려 이전 코드가 맞아보일수도 있어 보인다..**

```java
// TO-BE
public void testMultiplication() {
	Money five = Money.dollar(5);
	assertEquals(Money.dollar(10), new Dollar(10));
}

// AS-IS
public void testMultiplication() {
	Money five = Money.dollar(5);
	assertEquals(Money.dollar(10), five.times(2));
}
```

---

# 📌 논의해보고 싶었던 내용

## **📚 우리가 사는 시간**

> TDD를 하는 동안 계속 조율이 필요하다. 종종걸음으로 진행하는 것이 답답한가? 그러면 보폭을 조금 넓혀라. 성큼성큼 걷는 것이 불안한가? 그럼 보폭을 줄여라. TDD란 조종해 나가는 과정이다. 이쪽으로 조금, 저쪽으로 조금. 지금도, 그리고 앞으로도 정해진 올바른 보폭이라는 것은 존재하지 않는다
> 
> 📕  98p  3번째 ( 9장)
> 

### **🧐 : TDD를 하면서 가장 많이 하는 고민인것 같다. 리팩토링 또는 신규 테스트 로직을 구현하다 보면 기존의 로직을 수정하려고 할때 우선은 작업하던걸 마무리하고 다음에 수정하는게 맞을지.. 보인김에 같이 수정하는게 맞을지.. 우선은 답은 없는것 같으니 본인만의 기준을 정하고 페이스를 잘 맞춰야 할것 같다는 생각이 든다**

## **📚 삼각측량**

> 만약 라디오 신호를 두 수신국이 감지하고 있을 때, 수신국 사이의 거리가 알려져 있고 각 수신국이 신호의 방향을 알고 있다면, 이 정보들만으로 충분히 신호의 거리와 방위를 알 수 있다. 이 계산법을 삼각측량이라고 한다. 지은이는 어떻게 리팩토링해야 하는지 전혀 감이 안 올때만 삼각측량을 사용한다. 
> 
> 📕  61p  8번째 ( 3장)
> 

### **🧐 : 삼각측량을 하는 이유는 동일한 메서드로 다른 입력과 결과에 대해서 테스트를 작성하며 필요한 리팩토링을 하기 위함이다. 그런데 삼각측량을 어느 시점에 해야할지 또는 구현 로직에 필요하지 않는 부분이라면 스킵해도 될지 궁금하다**
