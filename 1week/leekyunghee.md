| Chapter | Title |
| -- | -- |
| 1장 | 다중 통화를 지원하는 Money 객체  |
| 2장 | 타락한 객체 |
| 3장 | 모두를 위한 평등 |
| 4장 | 프라이버시 |
| 5장 | 솔직히 말하자면 |
| 6장 | 돌아온 '모두를 위한 평등' |
| 7장 | 사과와 오렌지 |
| 8장 | 객체 만들기 |
| 9장 | 우리가 사는 시간 |
| 10장 | 흥미로운 시간 |



## 일반적인 TDD 주기는 다음과 같다.
1. 테스트를 작성한다. 마음 속에 있는 오퍼레이션이 코드에 어떤 식으로 나타나길 원하는지 생각해보라
   원하는 인페이스를 개발하라
2. 실행 가능하게 만든다.
3. 올바르게 만든다.

> 우리의 목적은 작동하는 깔끔한 코드를 얻는 것이다. "작동하는 깔끔한 코드" (이러한 접근 방식은 깔끔한 코드 부분을 먼저 해결한 후에 작동하는 부분을 해결해가면서 배운 것들을 설계에 반영하느라 허둥거리는 아키텍처 주도 개발과 정반대다.)
* 가짜로 구현하기 : 상수를 반환하게 만들고 진짜 코드를 얻을 대까지 단계적으로 상수를 변수로 바꾸어 간다.
* 명백한 구현 사용하기 : 실제 구현을 입력한다.
* 삼각측량(triangulation) 이라 부르는 세 번째 방법도 있다.

> 설계상의 결함을 그 결함으로 인해 실패하는 테스트로 변환했다.
> 스텁 구현으로 빠르게 컴파일을 통과하도록 만들었다.
> 올바르다고 생각하는 코드를 입력하여 테스트를 통과했다.

## 모두를 위한 평등 
 일반적으로 객체는 우리 예상대로 작동하지 않는다. 지금의 Dollor 객체 같이 객체를 값처럼 쓸 수 있는데 이것을 값 객체 패턴(value object pattern)이라고 한다. 값 객체에 대한 제약 사항중 하나는 객체의 인스턴스 변수가 생성자를 통해서 일단 설정된 후에는 결코 변하지 않는다는 것이다. 

## 프라이버시
 동치성 문제를 정의했으므로 이를 이용하여 테스트가 조금 더 많은 이야기를 해줄 수 있도록 만들자. 개념적으로 Dollor.times() 연산은 호출 받은 객체의 값에 인자로 받은 곱수만큼 곱한 값을 갖는 Dollor를 반환해야 한다. 
 - assertion을 Dollor와 Dollor를 비교하는 것으로 재작성할 수 있다. 
 public void testMultiplication() {
    Dollor five = new Dollor(5);
    Dollor product = five.times(2);
    assertEquals(new Dollor(10, product);
    product = five.times(3);
    assertEquals(15, product.amount);
}

지금까지 배운 것을 검토해보면 우리는
* 오직 테스트를 향상시키기 위해서만 개발된 기능을 사용했다.
* 두 테스트가 동시에 실패하면 망한다는 점을 인식했다.
* 위험 요소가 있음에도 계속 진행했다.
* 테스트와 코드 사이의 결합도를 낮추기 위해, 테스트하는 객체의 새 기능을 사용했다.

## 솔직히 말하자면
1. 테스트 작성.
2. 컴파일되게 하기
3. 실패하는지 확인하기 위해 실행.
4. 실행하게 만듦.
5. 중복 제거
각 단계에는 서로 다른 목적이 있다. 다른 스타일의 해법, 처음 네 단계는 빨리 진행해야 한다. 그러면 새 기능이 포함되더라도 잘 알고 있는 상태에 이를 수 있다.
중복이 엄청나게 많기 때문에  다음 테스트를 작성하기 전에 이것들을 제거해야 한다. equals()를 일반화하는 것부터 시작하자.

## 돌아온 '모두를 위한 평등'
Dollor가 Money를 상속받는다고 해도 여전히 어떤 것도 깨지지 않는다. 하위  클래스에서도 변수를 볼 수 있도록 가시성을 private에서 protected로 변경했다. 
이제 equals() 코드를 위로 올리는 일을 할 수 있게 됐다. 우선 임시변수를 선언하는 부분을 변경하자.
Dollor
public boolean equals(Object object) {
    Money dollor = (Dollor) object;
    return amount == dollor.amount;
}
> 공통된 코드를 첫 번째 클래스(Dollor)에서 상위 클래스(Money)로 단계적으로 옮겼다.
> 두 번째 클래스(Franc)도 Money의 하위 클래스로 만들었다.
> 불필요한 구현을 제거하기 전에 두 equals() 구현을 일치시켰다.


## 사과와 오렌지 
You can't compare apples and oranges. (서로 다른 걸 비교할 수 없다는 뜻.)
Fran과 Dollor를 비교하면 어떻게 될까? 동치성 코드에서는 Dollor가 Franc과 비교되지 않는지 검사해야 한다. 두 객체의 클래스를 비교함으로써 이러한 검사를 쉽게 수행할 수 있다. 오직 금액과 클래스가 서로 동일할 때 만 두 Money가 서로 같은 것이다. 

## 객체 만들기 
Money의 두 하위 클래스는 그다지 많은 일을 하는 것 같지 않으므로 아예 제거해버리고 싶다. 그런데 한번에 그렇게 큰 단계를 밟는 것은 TDD를 효과적으로 보여주기에 적절하지 않을 것 같다.
하위 클래스에 대한 직접적인 참조가 적어진다면 하위 클래스를 제거하기 위해 한 발짝 더 다가섰다고 할 수 있겠다. Money에 Dollor를 반환하는 팩토리 메서드를 도입할 수 있다. 
어떤 클라이언트 코드도 Dollor라는 이름의 하위 클래스가 있다는 사실을 알지 못한다. 하위 클래스의 존재를 테스트에서 분리(decoupling)함으로써 어떤 모델 코드에도 영향을 주지 않고 상속 구조를 마음대로 변경할 수 있게 됐다. 

## 우리가 사는 시간 
통화를 표현하기 위한 복잡한 객체들을 원할 수도 있다. 그 객체들이 필요한 만큼만 만들어지도록 하기 위해 경량 팩토리를 사용할 수 있을 것이다. 우린 두 클래스를 모두 포함할 수 있는 동일한 구현을 원한다.(Franc, Dollor) 
> 통화를 인스턴스 변수에 저장하고 메서드에서는 그냥 그걸 반환하게 만들 수 있을 것 같다.

## 흥미로운 시간
이 장을 끝내고 나면, Money를 나타내기 위한 단 하나의 클래스만을 갖게 될 것이다. 
