# XUnit으로 가는 첫걸음
## 테스트 프레임워크에 대한 할일 목록
* 테스트 메서드 호출하기
* 먼저 setUp 호출하기
* 나중에 tearDown 호출하기
* 테스트 메서드가 실패하더라도 tearDown 호출하기
* 여러 개의 테스트 실행하기
* 수집된 결과를 출력하기

## 첫번째 작은 단계는 아직 프레임워크가 없기 때문에 수동으로 테스트 케이스를 검증하자.
클래스를 정의하기 전에 테스트 코드부터 작성하기
클래스와 메서드를 정의하고 리팩토링 진행하기

## 리팩토링의 일반적인 패턴
하나의 특별한 사례에 대해서만 작동하는 코드를 가져다가 다른 여러 사례에 대해서도 작동할 수 있도록 상수를 변수로 변화시켜 일반화하는 것

일단 한 번만 수동으로 검증하면 앞으로는 이 과정을 자동화할 수 있다. 
- 하드코딩을 한 다음에 상수를 변수로 대체하여 일반성을 이끌어내는 방식으로 기능을 구현했다.

- 부트스트랩 to load a program into a computer using a much smaller initial program to load in the desired program (which is usually an operating system)
- 플러거블 셀렉터(pluggable selector) Replace subclasses with dynamically generated method calls. 장점은 객체 별로 서로다른 메서드가 동적으로 호출되게 함으로써 필요 없는 하위클래스의 생성을 피한다.

# 테이블 차리기
테스트를 작성하다보면 공통된 패턴을 발견하게 된다. 
* 준비(arrange): 객체를 생성
* 행동(act): 어떠한 자극을 준다.
* 확인(assert): 결과를 검사한다.

# 실패 처리하기
테스트가 작동하도록 하려면 예외를 잡아야하고 현재까지의 구현에서는 예외가 보고되지 않기 때문에 이를 위한 작업을 진행한다.
테스트 결과를 반환해주는 클래스를 만들고 n개 성공 n개 실패라는 결과문을 반환해준다. 
 


## 테스트 주도  개발 패턴
테스트를 하기 위한 기본 전략
테스트를 한다는 것은 무엇을  뜻하는가? 언제해야  하는가? 테스트할 로직을  어떻게 고르고 데이터는 어떻게 고를까?

## 테스트  명사와  동사
평가하다라는 뜻 승인 또는 거부에 도달하는 과정

질문 해볼만한 내용
- 실패할 게 뻔하더라도 테스트를 작성한 후에는 반드시 실행해봐야 할까? 트랜젝션을 시작하고 변수를  변경한 후에 트랜젝션이 가비지 컬렉트에 되도록 둔 경우에 롤백을 어떻게  구현할 건가?
- 트랜젝션 메커니즘이란 결국 트렌젝션이 커밋되기 전까지  변수가 진짜로 변하면  안된다는 것에 있다.

## 격리된 테스트
테스트를  실행시 서로 아무런 영향이 없어야 한다. 독립적으로 테스트가  실행되야야 함
성능 문제는 테스트가 데이터를 공유해야 하는 이유로 이는 주어진 문제를 작은 단위로 분리하기 위해  노력해서 각  테스트를 실행하기 위한 환경을 쉽고 빠르게 세팅 할 수 있게 해야 한다는 것이다. 
테스트를 격리하기 위한 작업은 결과적으로 시스템이 응집도는 높고 결합도는 낮은 객체의 모음으로 구성되도록 한다. 응집도는 높이고 결합도는 낮춘다.  
