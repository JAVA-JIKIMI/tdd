# XUnit으로 가는 첫걸음
## 테스트 프레임워크에 대한 할일 목록
* 테스트 메서드 호출하기
* 먼저 setUp 호출하기
* 나중에 tearDown 호출하기
* 테스트 메서드가 실패하더라도 tearDown 호출하기
* 여러 개의 테스트 실행하기
* 수집된 결과를 출력하기

## 첫번째 작은 단계는 아직 프레임워크가 없기 때문에 수동으로 테스트 케이스를 검증하자.
클래스를 정의하기 전에 테스트 코드부터 작성하기
클래스와 메서드를 정의하고 리팩토링 진행하기

## 리팩토링의 일반적인 패턴
하나의 특별한 사례에 대해서만 작동하는 코드를 가져다가 다른 여러 사례에 대해서도 작동할 수 있도록 상수를 변수로 변화시켜 일반화하는 것

일단 한 번만 수동으로 검증하면 앞으로는 이 과정을 자동화할 수 있다. 
- 하드코딩을 한 다음에 상수를 변수로 대체하여 일반성을 이끌어내는 방식으로 기능을 구현했다.

- 부트스트랩 to load a program into a computer using a much smaller initial program to load in the desired program (which is usually an operating system)
- 플러거블 셀렉터(pluggable selector) Replace subclasses with dynamically generated method calls. 장점은 객체 별로 서로다른 메서드가 동적으로 호출되게 함으로써 필요 없는 하위클래스의 생성을 피한다.

# 테이블 차리기
테스트를 작성하다보면 공통된 패턴을 발견하게 된다. 
* 준비(arrange): 객체를 생성
* 행동(act): 어떠한 자극을 준다.
* 확인(assert): 결과를 검사한다.

# 실패 처리하기
테스트가 작동하도록 하려면 예외를 잡아야하고 현재까지의 구현에서는 예외가 보고되지 않기 때문에 이를 위한 작업을 진행한다.
테스트 결과를 반환해주는 클래스를 만들고 n개 성공 n개 실패라는 결과문을 반환해준다. 
 


## 테스트 주도  개발 패턴
테스트를 하기 위한 기본 전략
테스트를 한다는 것은 무엇을  뜻하는가? 언제해야  하는가? 테스트할 로직을  어떻게 고르고 데이터는 어떻게 고를까?

## 테스트  명사와  동사
평가하다라는 뜻 승인 또는 거부에 도달하는 과정

질문 해볼만한 내용
- 실패할 게 뻔하더라도 테스트를 작성한 후에는 반드시 실행해봐야 할까? 트랜젝션을 시작하고 변수를  변경한 후에 트랜젝션이 가비지 컬렉트에 되도록 둔 경우에 롤백을 어떻게  구현할 건가?
- 트랜젝션 메커니즘이란 결국 트렌젝션이 커밋되기 전까지  변수가 진짜로 변하면  안된다는 것에 있다.

##  테스트 목록
경험이 축적될 수록 할일이 많아진다. 할일 목록이 많아질수록 내가 하던 일에 대한 집중력이 떨어지고 성취도는 낮아진다. 성취도가 낮아지면 할일 목록은 더 많아진다. 현재 내상태
현재 작업 범위를 넘어서는 큰 리팩토링 거리를 발견한다면 '다음'  할일 목록으로 넘겨라.

## 단언 우선
테스트를 작성할 때 단언은 언제쯤 쓸까? 단언을 제일 먼저 쓰고 시작하하.

## 테스트 데이터
테스트를 읽을 때 쉽고 따라가기 좋을 만한 데이터를 사용하라.
테스트 데이터의  패턴의 한 가지 트릭은 여러 의미를 담는 동일한 상수를 쓰지 않는 것이다.  

## 명백한 데이터
데이터의 의도를 어떻게 표현할 것인가? 테스트 자체에 예상되는 값과 실제 값을 포함하고 이 둘 사이의 관계를 드러내기 위해 노력하라. 

## 회귀 테스트
회귀 버그를 찾는 모든 소프트웨어 테스트 방식은 회귀 테스트라 할 수 있다. 회귀 버그는 이전에 제대로 작동하던 소프트웨어 기능에 문제가 생기는 것을 가리킨다.

## XUnit 패턴 
단언은 구체적이어야 한다.  
일반적으로 예상되는 값을 먼저 적어주면 JUnit에서는 이것을 assertEqual(50, rectangle.area())처럼 나타낼 수 있다. 


## 격리된 테스트
테스트를  실행시 서로 아무런 영향이 없어야 한다. 독립적으로 테스트가  실행되야야 함
성능 문제는 테스트가 데이터를 공유해야 하는 이유로 이는 주어진 문제를 작은 단위로 분리하기 위해  노력해서 각  테스트를 실행하기 위한 환경을 쉽고 빠르게 세팅 할 수 있게 해야 한다는 것이다. 
테스트를 격리하기 위한 작업은 결과적으로 시스템이 응집도는 높고 결합도는 낮은 객체의 모음으로 구성되도록 한다. 응집도는 높이고 결합도는 낮춘다.  

### 디자인 패턴
## 플러거블 셀렉터
인스턴스 별로 서로 다른 메서드가 동적으로 호출되게 하려면 어떻게 해야할까?  메서드의 이름을  저장하고 있다가 그 이름에 해당하는 메서드를 동적으로 호출한다.
- 인스턴스 생성하는 곳,  switch  문, 메서드 자체 : 새로운 종류의 출력을 추가할 때마다 출력 메서드를 추가하고 switch 문을 바꿔야 한다는 점을 기억해야 한다. 281p
- 플러거블 셀렉터 해법은 리플렉션을 이용하여 동적으로 메서드를 호출하는 것이다.

# 팩토리 메서드
- 메서드라는  한 단계의 인터렉션을 추가함으로써 테스트를 변경하지 않고 다른 클래스의 인스턴스를 반환할 수 있는 유연함을 얻었다. 이 메서드를 팩토리 메서드라 부르는데 객체를 생성하기 때문이다. 283p

# 컴포지트 
- 객체의 집한을 단일 객체처럼 취급할 수 있다.
- 하나의 객체가 다른 객체 목록의 행위를 조합한 것처럼 행동하게 만들려면 어떻게 해야할까? 객체 집한을 나타내는 객체를 단일 객체에 대한 임포스터로 구현한다.

###  리펙토링
# 변화 격리하기
객체나 메서드의  일부만 바꾸려면 바꿔야 할 부분을 격리한다. 
변화를 격리하기 위해 사용할 수 있는 몇 가지 방법에는 메서드 추출하기, 객체 추출하기, 메서드  객체 등

###  TDD 마스터하기
각 테스트가 다뤄야 할 범위는  얼마나  넓은가?
리펙토링을 하면서 얼마나 많은 중간 단계를  거처야  하는가?

